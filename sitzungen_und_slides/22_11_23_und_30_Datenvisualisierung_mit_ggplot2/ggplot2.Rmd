---
title: "Data Visualization with ggplot2 - The Berlin Rental Market"
author: "Moritz Valentino Donatello Matzner"
date: "Today"
output:
  beamer_presentation:
    theme: default
 #   fonttheme: structurebold
    slide_level: 2
  ioslides_presentation: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(message = F, warning = F, error = F)
```
# Goals for today


# Setting up Our Script and Glimpsing at the Data

## Importing and Loading

-   Import and load libraries

```{r warning = FALSE}
#install.packages("ggplot2") # used for plotting 
#install.packages("dplyr") # used for basic data wrangling
library(ggplot2)
library(dplyr)
library(sf)
```

-   Import data

```{r}
immo <- read.csv("../data/berlin_rental_market/immoscout.csv", sep=";")
```

# The Data Set

-   Two functions can help us get a first grasp our dataset: `glimpse` and `summary`

```{r}
glimpse(immo)
```

------------------------------------------------------------------------

```{r}
summary(immo)
```
# The Grammar of Graphics

-   ggplot is based on the *Grammar of Graphics* by Leland Wilkinsonn (1999).
-   GG decomposes graphics into its constituents (words) and explores how they relate to each other (the grammar).\
-   data, mapping, statistics, scales, geometries, facets, coordinates, themes

------------------------------------------------------------------------

## *mapping = aesthetics mapping*
-   links variables in data to graphical properties in the geometry
-   what variables are grabbed from in the data to be in the plot (x-axis, the color, the size, ..)

***
```{r, , out.width="75%"}
ggplot(data = immo) +
  geom_point(mapping = aes(x=Rent, y=Area)) +
  theme_classic()
```

------------------------------------------------------------------------

##  *statistics*
- Apply a statistical transformation to the data
- Every geom has its statistics
- Often, this is implicit, as in a boxplot or a density plot when it is "just" computed

***

```{r, out.width="75%"}
ggplot(data = immo) +
  geom_boxplot(mapping= aes(x = Vermieter_typ, y=log(Rent)))+
  theme_classic()
```

***

- E.g. Geom_bar counts all observation by class --> the "count" is not present in the data!

```{r, out.width="50%", fig.align="center"}
ggplot(data=immo) +
  geom_bar(aes(x=Vermieter_typ)
           ) +
  theme_classic()

```
***

- If you know what you want, you can override the stat 
```{r , out.width="50%", fig.align="center"}
ggplot(data=immo) +
  geom_bar(aes(
    x=Vermieter_typ, 
    y=after_stat(100*count/sum(count))
  ))
```

***
- You can as well change the way the statistics are computed 
```{r}
histo_1 <- ggplot(data=immo) +
  geom_histogram(aes(x=log(Rent), 
                     fill=Vermieter_typ)) +
  theme_classic()


histo_2 <- ggplot(data=immo) +
  geom_histogram(aes(x=log(Rent), 
                     fill=Vermieter_typ),  
                 position = "dodge") +
  theme_classic()
```

***

```{r, figures-side, fig.show="hold", out.width="40%"}
histo_1
histo_2
```


***

```{r , out.width="75%"}
density <- ggplot(data = immo) +
  geom_density(aes(x=log(Rent), 
                   fill=Vermieter_typ), 
               alpha=0.5
               )+
  theme_classic()
```

***

```{r}
density
```




***
- Or add statistics to your plot! 
- This is important to have a statistical confirmation for a visual interpretation
```{r }
jitter <- 
  ggplot(immo, 
       aes(x=Vermieter_typ, 
                  y=log(Rent)
           )
       ) +
  geom_jitter(width = 0.4,
              size = 0.05,
              alpha=0.5) +
  stat_summary(fun = median, 
               geom = "point", 
               color= "red", 
               size=2) +
  theme_classic()
```

*** 
 
```{r}
jitter
```
 

***
- The jitter plot doesnt really tell us something about the distribution - let's add a ```geom_violin```!
```{r , out.width="75%"}
jitter + geom_violin(alpha=0.5)
```



------------------------------------------------------------------------

##   *scales*
-   Data can have different types of scales: continuous, categorical, time and data.
-   Most data does not directly represent graphical properties: as ```Vermieter_typ```
-   Scale translates: from categories to colors | numbers to position
- Everything inside ```aes()``` has a scale - if none is provided, it will get a default
- scale goes like: "What is inside the aes?, what kind of variable do we have?" 
--> If we use ```color``` for the categorical variable ```Vermieter_typ``` we will get a discrete color scale, not a continuous one!

***
```{r fig. }
jitter_color <- 
  ggplot(immo, 
       aes(x=Vermieter_typ, 
           y=log(Rent), 
           color=Vermieter_typ
           )
       ) +
  geom_jitter(width = 0.4,
              size = 0.05,
              alpha=0.5) +
  stat_summary(fun = median, 
               geom = "point", 
               color= "DarkRed", 
               size=2) +
  theme_classic() +
  theme(legend.position="none") 
```

***

```{r}
jitter_color
```


***

## Colors <3 
- We can change everything - so surely as well these ugly colors ggplot is providing...
- We *add* a scale - e.g. "brewer" which is a collection of colors and a palette 

```{r}
jitter_color_violin <- 
  jitter_color +
  scale_color_brewer(type = "qual", 
                     palette = "Set1") +
  geom_violin(alpha=0.5)
```

***

```{r}
jitter_color_violin
```

***

## *geometries*
- How to interpret mapping=aesthetics as graphical representations 
- is it a set of points - or a line? Or both? 
- pretty much determines your plot type: geom_bar, geom_violin.. or geom_smooth?

***
```{r}
ggplot(subset(immo, Rent < 2000)) +
  geom_point(aes(x=Area, 
                  y=Rent, 
                  color=Vermieter_typ), 
             size=0.1, 
             alpha=0.5
              ) +
  theme_classic()
```

```{r}
ggplot(subset(immo, Rent < 2000)) +
  geom_smooth(aes(x=Area, 
                  y=Rent, 
                  color=Vermieter_typ)
              ) +
  theme_classic()
```

```{r}
ggplot(subset(immo, Area < 120 & Rent < 2500)) +
  geom_point(aes(x=Area, 
                  y=Rent, 
                  color=Vermieter_typ), 
             size=0.1, 
             alpha=0.5
              ) +
  geom_smooth(aes(x=Area, 
                  y=Rent, 
                  color=Vermieter_typ)
              ) +
  theme_classic()
```

## *facets*
- Every plot has a plotting area
- Facets allows you to plot multiples: plots that share the same logic but with different data bases. 
- is there any plot that we saw that might benefit from such a transformation?

***
```{r, out.width="75%"}
density +
  scale_fill_brewer(type = "qual", 
                     palette = "Set1") 
```

***
```{r, out.width="75%"}
density_facet <- 
  ggplot(data = immo) +
  geom_density(aes(x=log(Rent), 
                   fill=Vermieter_typ), 
               alpha=0.5
               )+
  facet_grid(rows=vars(Vermieter_typ))+
  theme_classic() +
  scale_fill_brewer(type = "qual", 
                     palette = "Set1") +
  theme(legend.position="none") # removes the legend
```

***
```{r}
density_facet
```

***

## Coordinates
- A physical mapping of the mapping= aesthetics in a coordinate system
- That is why we can easily plot maps and georeferenced data!

***
- What kind of issue do you see with this plot? 
- How can we solve it? 

```{r echo=F}
plot_wrong <- ggplot(immo) +
  geom_point(mapping= aes(x=lat, y=lng, color=Vermieter_typ)) +
  theme_classic() 
plot_wrong
```

***
- We can do changes on two fronts: filter the data or define the limits of the coordinate system without changing the underlying data! 
```{r , out.width="25%"}
# we can filter the data 
ggplot(subset(immo, lng>12)) +
  geom_point(mapping= aes(x=lat, y=lng, color=Vermieter_typ)) +
  theme_classic() 

# or 
plot_wrong +
  scale_y_continuous(limits=c(13, 13.8))+
  scale_x_continuous(limits=c(52.35, 52.6))

plot_wrong +
  coord_cartesian(ylim=c(13, 13.8), 
                  xlim=c(52.35, 52.7))
```


***
- What other issues do you see with the plot?

```{r}
immo_filtered <- immo %>%
  filter(lng > 12)

coordinates <- ggplot(immo_filtered) +
  geom_point(mapping= aes(x=lat, 
                          y=lng, 
                          color=Vermieter_typ)
             ) +
  theme_classic() 
```

***

```{r}
coordinates
```

***

```{r}
coordinates <- ggplot(immo_filtered) +
  geom_point(mapping= aes(x=lat, 
                          y=lng, 
                          color=Vermieter_typ), 
             size=0.1, 
             alpha=0.5) +
  theme_classic() 
```



***

Just a quick look at what other geoms there are.. 
```{r}
density_geom <- 
  ggplot(immo_filtered) +
  geom_point(mapping= aes(x=lat, y=lng, color=Vermieter_typ), 
             size=0.1, 
             alpha=0.5) +
  geom_density_2d(aes(x=lat, y=lng, color=Vermieter_typ), 
                  alpha=0.5) +
  theme_classic() 
```

***
```{r}
density_geom
```


## Scales, colors and coordinates

- So far, we only mapped color to discrete, but not continuous variables. 

```{r , out.width="50%"}
continous <- 
  ggplot(data=immo_filtered) +
  geom_point(aes(x=lat, 
                 y=lng, 
                 color=sqm_price),
             size=0.3,
             alpha=1) +
  theme_classic()
  
```

***

```{r}
continous
```


***
## Color Palette 
- Many color palettes derived from RGB combinations (like the "rainbow" color palette) are not suitable to support all viewers, especially those with color vision deficiencies. 
- Using viridis type, which is perceptually uniform in both colour and black-and-white display is an easy option to ensure good perceptive properties of your visulizations. 
- Since the distribution is not normal, it can make sense to define breaks 

***
```{r}
vidris_plot <- 
  ggplot(immo_filtered) +
  geom_point(aes(x=lat, 
                 y=lng, 
                 color=sqm_price),
             size=0.75) +
  scale_color_viridis_b(limits=c(10, 30)) +
  theme_classic()
```
***

```{r}
vidris_plot
```


***

## Spatial Data
```{r , message=T}
# transform the data to a spatial system 
immo_spatial <- immo_filtered %>%
  filter(!is.na(lng) & !is.na(lat) & lng > 13)

points <- st_as_sf(immo_spatial, 
                   coords = c("lng", "lat"), 
                   crs = 4326, agr = "constant")

# load the berlin street data 
streets_berlin <- st_read("../data/berlin_geometries/straßen_berlin/Straßenabschnitte.shp")

berlin <- ggplot() +
  geom_sf(data=streets_berlin, 
          size=0.1) +
  geom_sf(data = points, 
          size=0.3, 
          alpha=0.75,
          mapping= aes(color=Vermieter_typ)) +
  theme_bw()
```

***

## Spatial Data
```{r , message=T}
# transform the data to a spatial system 

immo_spatial_bezirk <- immo_filtered %>%
  filter(!is.na(lng) & !is.na(lat) & lng > 13) %>%
  filter(district=="Neukoelln")

points_bezirk <- st_as_sf(immo_spatial_bezirk, 
                   coords = c("lng", "lat"), 
                   crs = 4326, agr = "constant")

# load the berlin street data 
streets_berlin_bezirk <- st_read("../data/berlin_geometries/straßen_berlin/Straßenabschnitte.shp") %>%
  filter(BEZIRK=="Neukölln")

berlin_bezirk <- ggplot() +
  geom_sf(data=streets_berlin_bezirk, 
          size=0.1) +
  geom_sf(data = points_bezirk, 
          size=0.3, 
          alpha=0.75,
          mapping= aes(color=Vermieter_typ)) +
  theme_bw()
```

***

```{r}
berlin
```


***

#Color 

- Adding a color scale for a continous variable
- We define the limits since this is where the most variation is going on

```{r}
berlin_sqm <- 
  ggplot() +
  geom_sf(data=streets_berlin, 
          size=0.1) +
  geom_sf(data = points, 
          size=0.4, 
          alpha=0.75,
          mapping= aes(color=sqm_price)) +
  scale_color_viridis_b(limits=c(10, 25)) +
  theme_void()
```
***

```{r}
berlin_sqm
```


***
## Overplotting? 
- Let's facet this plot by ```Vermieter_typ```

```{r}
facet_berlin <- ggplot() +
  geom_sf(data=streets_berlin, 
          size=0.1) +
  geom_sf(data = points, 
          mapping = aes(color=Vermieter_typ), 
          size=0.5) +
  facet_wrap(~Vermieter_typ) +
  theme_classic() +
  theme(legend.position="none")

```

***

```{r}
facet_berlin
```

***

## Theme

- this is the ```+ theme_classic()``` part that we have been adding to the plot 
- You apply ready-made themes and / or modify them.
- themeing is hierarchical (as a lot in ggplot.. )
- there is a variety of themes.. have fun with finding your favourite one :) 

***

```{r}
facet_berlin +
  labs(title= "Berlin: Spatial Dimension of Rental Apartment's Ownership Structure", 
       caption = "Source: 5.129 Listings scraped in the Summer of 2020") +
  theme(
    # text = element_text('Avenir Next Condensed',
    #                     color = "SteelBlue",
    #                     size = 12), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
    )
```


## Key Take Aways :) 

- Mapping inside the aesthetics! 
- Change how stuff looks: geoms 
- Change the colors: scales
- Everything inside ```aes()``` has a scale - if none is provided, it will get a default
- scale goes like: "What is inside the aes?, what kind of variable do we have?" 

# Wrangling

For this session, we want to select two districts of Berlin and compare them. Use the dplyr stuff we learned last time to create a database called ```immo_filtered```

```{r}
immo_filtered <- immo %>%
  filter(district =="Neukoelln" | district == "Mitte") 
```

# Let's plot :) 

- Create your first plot using two continuous variables. 

```
ggplot(data = ____, 
       ______ = AES(___, 
                   ____)) +
  geom_point()
```


***
- How can you improve the basic plot given that you want to compare two districts?

***


```{r , out.width="50%"}
ggplot(data = immo_filtered) +
  geom_point(mapping = aes(x=log(Area), 
                           y=log(Rent), 
                           shape=district, 
                           color=district)) +
  theme_classic()

```

***
## Setting vs. Mapping colors 

To make plot more readable, we want to reduce the ```size``` and ```alpha``` of all points. Where should the specification go? 
***
```{r , , eval=F}
ggplot() +
  geom_point(data = immo_filtered,
             mapping = aes(x=log(Rent), 
                           y=log(Area),
                           shape=district, 
                           color=district),
             size=0.75, 
             alpha=0.5) +
  theme_classic()
```

***
## Statistics  
- Now comapre the distribution of rent in two districts you are interested in using a boxplot and a histogram
- Mapping requirements differ - if you want to find out about them in this case, hit e.g.  ?geom_histogram. 
- Scroll down - to the arguments that are bold. 
***
- How would you interpret the histogram? 
```{r , , eval=F}
boxplot <- ggplot(data = immo_filtered,
       aes(y=log(Rent))) +
  geom_boxplot(aes(color = district)) +
  theme_classic()
boxplot

ggplot(data = immo_filtered,
       aes(x=log(Rent))) +
  geom_histogram(aes(fill = district))+
  theme_classic()
```

***
```{r , , eval=F}
ggplot(data = immo_filtered,
       aes(y=log(Rent))) +
  geom_boxplot(aes(color = district)) +
  theme_classic()

ggplot(data = immo_filtered,
       aes(x=log(Rent))) +
  geom_histogram(aes(fill = district), 
                 position = "identity" # the default option is stack!
                 )+
  theme_classic()
```

***
- Can you find another problem with the boxplot and the histogram? 

```{r}
boxplot
```


***
## Issues: 
- we are using absolute rent, not adjusted by square meter 
- the N between the two districts differ. 

--> use dplyr to compute the sqm_rent, save the variable and plot it. 

***

```{r }
immo_filtered_2 <- immo_filtered %>%
  mutate(sqm_rent=Rent/Area)
```

```{r, eval=F}
ggplot(data = immo_filtered_2, 
       aes(x=log(sqm_rent))) +
  geom_density(aes(fill=district), 
               alpha=0.5) +
  facet_wrap(rows=vars(district))+
  theme_classic() +
  theme(legend.position="none")
```
***
- What is missing in this plot?

```{r , out.width="10%"}
ggplot(data = immo_filtered_2, 
       aes(x=district,
           y=log(sqm_rent))
       ) +
  geom_jitter(alpha=0.5) +
  stat_summary(fun = median, 
               color="SteelBlue", 
               size=1) +
  theme_classic()
```

***

- The distribution! 

```{r}
ggplot(data = immo_filtered_2,  
       aes(x=district,
           y=log(sqm_rent))
       ) +
  geom_jitter(alpha=0.5) +
  stat_summary(fun = median, 
               color="SteelBlue", 
               size=1) +
  geom_violin(alpha=0.5, 
              color="SteelBlue") +
  theme_classic()
```

***
- Bubble chart
```{r}
set.seed(10)
immo_reduced <- sample_n(immo_filtered_2, 100)

bubble <- ggplot(data=immo_reduced) +
  geom_point(aes(x=Rent, 
                 y=Area, 
                 size=Rooms, 
                 color=district), 
             alpha=0.75) +
  scale_color_brewer(type = "qual", 
                    palette = "Set1") +
  theme_classic()

```

```{r}
bubble
```

